#include "Game.h"

Game :: Game()
{

gameRender = new Render(WIDTH, HEIGHT, BPP, SDL_HWSURFACE | SDL_DOUBLEBUF );

//gameRender = new Render(WIDTH, HEIGHT, BPP, SDL_SWSURFACE );
initMap(0,2);
done = false;
space = false;
IDbase=1;
}

Game ::~Game()
{

}

void Game :: initMap(int initColor, int gravConst)
{
gravitationalConstant =gravConst;
#pragma omp parallel for	
for(int i=0 ; i< WIDTH ; i++)
	for(int j =0 ; j<HEIGHT ; j++)
		{
		topMap[i][j] = new Pixel_desc;
		
		topMap[i][j]->x=i;
		topMap[i][j]->y=j;
		
		topMap[i][j]->color=initColor; 

		topMap[i][j]->mass = 0;

		topMap[i][j]->xVel = 0;
		topMap[i][j]->yVel = 0;
		topMap[i][j]->xAcc = 0;
		topMap[i][j]->yAcc = 0;
		
		topMap[i][j]->xGacc = 0;
		topMap[i][j]->yGacc = 0;



		topMap[i][j]->accelLength = 0;
		topMap[i][j]->updated = 0;
		topMap[i][j]->dimFactor = 0;

	//Init gravity map at this point
		gravMap[i][j] = new Grav_desc;
		
		gravMap[i][j]->x=i;
		gravMap[i][j]->y=j;

		gravMap[i][j]->gXacc = 0;
		gravMap[i][j]->gYacc = 0;
	
		}
}

void Game :: assignMapElement(  int x, int y,
				int color,
				int xAccel,
				int yAccel,
				int accLength,
				int dimFactor,
				int mass )
{		
		//assign location
		topMap[x][y]->x=x;
		topMap[x][y]->y=y;
		
		//assign color	
		topMap[x][y]->color=color; 
	
		//if it has mass
		if(mass!=0)
		{//assign amss and add to massList
		topMap[x][y]->mass = mass;
	  	massList.push_back(topMap[x][y]);
	  	}

		//intit velocity to zero, set accel
		topMap[x][y]->xVel = 0;
		topMap[x][y]->yVel = 0;
		topMap[x][y]->xAcc = xAccel;
		topMap[x][y]->yAcc = yAccel;

		topMap[x][y]->ID=IDbase++;

		//set accellength:number of times to apply this accel to vel
		topMap[x][y]->accelLength = accLength;
		topMap[x][y]->updated = 0;

		//set dimfactor:higher=pixel fades away quicker
		topMap[x][y]->dimFactor = dimFactor;

}


void Game :: parseMapToSurface()
{


if (SDL_MUSTLOCK(gameRender->mainScreen)) 
    SDL_LockSurface(gameRender->mainScreen);	



int x, y, i, j, color, screenID=0;
 #pragma omp parallel for private(x,y,color, i, j)
 for( i=0 ; i< WIDTH ; i++)
	for(j =0 ; j<HEIGHT ; j++)
		{
		x =	topMap[i][j]->x;
		y =	topMap[i][j]->y;
		color =	topMap[i][j]->color;
		
		gameRender->putPixel(x,y,color,screenID);
		}


    if( SDL_MUSTLOCK(gameRender->mainScreen) )
        SDL_UnlockSurface(gameRender->mainScreen);


}
void Game :: updateSelectPix()
{
	for(int i; i<pixelList.size() ;i++)
	{
	
	if(topMap[x][y]->updated == 0 && topMap[x][y]->color!=0)
    		{
		/*ASSIGN VALUES TO TEMP STORAGE*/
		tmp_color  = topMap[x][y]->color;

		tmp_xAccel = topMap[x][y]->xAcc;
		tmp_yAccel = topMap[x][y]->yAcc;

		tmp_xVel = topMap[x][y]->xVel;
		tmp_yVel = topMap[x][y]->yVel;
	
		tmp_dimFactor = topMap[x][y]->dimFactor;
	//check that accel should be applied
	if(topMap[x][y]->accelLength != 0)
   	   {
		//add accels to velocity components
		tmp_xVel = tmp_xVel + tmp_xAccel;
		tmp_yVel = tmp_yVel + tmp_yAccel;
		
		//decrement accelLength	
		topMap[x][y]->accelLength--;
	
		//if accelLength is now zero, go ahead
		//and rest the accel to zero	
		if(topMap[x][y]->accelLength ==0)
		{
		topMap[x][y]->xAcc = 0;
		topMap[x][y]->yAcc = 0;
		topMap[x][y]->accelLength = -1;
		}

	   }

	//apply grav accel
	tmp_xVel +=topMap[x][y]->xGacc;
	tmp_yVel +=topMap[x][y]->yGacc;



	if(tmp_dimFactor)
	{
		int tmpR = (tmp_color & 0xFF0000)>>16;
		int tmpG = (tmp_color & 0x00FF00)>>8;
		int tmpB = (tmp_color & 0x0000FF);
	
	if(tmpR < tmp_dimFactor)
		{tmpR=0;}
		else
		{tmpR-=tmp_dimFactor;}

	if(tmpG < tmp_dimFactor)
		{tmpG=0;}
		else
		{tmpG-=tmp_dimFactor;}

	if(tmpB < tmp_dimFactor)
		{tmpB=0;}
		else
		{tmpB-=tmp_dimFactor;}

	tmp_color = (tmpR<<16) | (tmpG<<8) | tmpB;
	}

	int newX = x + tmp_xVel;
	int newY = y + tmp_yVel;
	
	//if y and x have not changed, reassign recalced stuff
	if(newX ==x && newY==y){topMap[newX][newY]->color = tmp_color;}
	
	//if new location is different, reassign pixel_desc structs
	if(newX!=x || newY!=y )
	   {
		/* THESE REVERSE VELOCITY IF THE EDGE OF SCREEN IS REACHED*/
		if(newX<=0){newX=1;tmp_xVel=tmp_xVel*(-1);}

		if(newX>=WIDTH){newX=WIDTH-1;tmp_xVel=tmp_xVel*(-1);}

		if(newY<=0){newY=1;tmp_yVel=tmp_yVel*(-1);}

		if(newY>=HEIGHT){newY=HEIGHT-1;tmp_yVel=tmp_yVel*(-1);}	
		
		//posistion is finalized, set color
		topMap[newX][newY]->color = tmp_color;
		
		//double check position, probably not needed
	   if((newX>0 && newX<WIDTH) && (newY>0 && newY<HEIGHT))
	      {

	//find in mass List to switch pointer
	for(int i=0; i<massList.size();i++)
		{
		if(massList[i]->x == x && massList[i]->y == y)
			massList[i] = topMap[newX][newY];
		}

		topMap[newX][newY]->x = newX;
		topMap[newX][newY]->y = newY;


		topMap[newX][newY]->accelLength = topMap[x][y]->accelLength;

		topMap[newX][newY]->mass = topMap[x][y]->mass;


		

		topMap[x][y]->mass=0;

		topMap[newX][newY]->xAcc = topMap[x][y]->xAcc;
		topMap[newX][newY]->yAcc = topMap[x][y]->yAcc;

		topMap[newX][newY]->xGacc = topMap[x][y]->xGacc;
		topMap[newX][newY]->yGacc = topMap[x][y]->yGacc;

		topMap[newX][newY]->xVel = tmp_xVel;
		topMap[newX][newY]->yVel = tmp_yVel;

		topMap[newX][newY]->ID = topMap[x][y]->ID;

		topMap[newX][newY]->updated=1;
		topMap[newX][newY]->dimFactor=tmp_dimFactor;
		
		topMap[x][y]->color=0;

		topMap[x][y]->xAcc=0;
		topMap[x][y]->yAcc=0;

		topMap[x][y]->accelLength=0;

		topMap[x][y]->ID=0;

		topMap[x][y]->xVel=0;
		topMap[x][y]->yVel=0;
		topMap[x][y]->updated=0;
		topMap[x][y]->dimFactor=0;
	      }
//	printf("ID[%d]:old->:(%d,%d) vel:(%d,%d)\nnew->:(%d,%d) vel:(%d,%d)\n\n",
//topMap[newX][newY]->ID,	x,y,topMap[x][y]->xVel,topMap[x][y]->yVel, newX,newY,tmp_xVel,tmp_yVel);
	   
	}
   }


	
	}

}


void Game :: updateMap()
{
 int tmp_color, tmp_xAccel, tmp_yAccel, tmp_xVel, tmp_yVel, tmp_dimFactor;


for(int x = 0 ; x<WIDTH ; x++)
 {
  for(int y = 0; y<HEIGHT ;y++)
  {
    if(topMap[x][y]->updated == 0 && topMap[x][y]->color!=0)
    {
		/*ASSIGN VALUES TO TEMP STORAGE*/
		tmp_color  = topMap[x][y]->color;

		tmp_xAccel = topMap[x][y]->xAcc;
		tmp_yAccel = topMap[x][y]->yAcc;

		tmp_xVel = topMap[x][y]->xVel;
		tmp_yVel = topMap[x][y]->yVel;
	
		tmp_dimFactor = topMap[x][y]->dimFactor;
	//check that accel should be applied
	if(topMap[x][y]->accelLength != 0)
   	   {
		//add accels to velocity components
		tmp_xVel = tmp_xVel + tmp_xAccel;
		tmp_yVel = tmp_yVel + tmp_yAccel;
		
		//decrement accelLength	
		topMap[x][y]->accelLength--;
	
		//if accelLength is now zero, go ahead
		//and rest the accel to zero	
		if(topMap[x][y]->accelLength ==0)
		{
		topMap[x][y]->xAcc = 0;
		topMap[x][y]->yAcc = 0;
		topMap[x][y]->accelLength = -1;
		}

	   }

	//apply grav accel
	tmp_xVel +=topMap[x][y]->xGacc;
	tmp_yVel +=topMap[x][y]->yGacc;



	if(tmp_dimFactor)
	{
		int tmpR = (tmp_color & 0xFF0000)>>16;
		int tmpG = (tmp_color & 0x00FF00)>>8;
		int tmpB = (tmp_color & 0x0000FF);
	
	if(tmpR < tmp_dimFactor)
		{tmpR=0;}
		else
		{tmpR-=tmp_dimFactor;}

	if(tmpG < tmp_dimFactor)
		{tmpG=0;}
		else
		{tmpG-=tmp_dimFactor;}

	if(tmpB < tmp_dimFactor)
		{tmpB=0;}
		else
		{tmpB-=tmp_dimFactor;}

	tmp_color = (tmpR<<16) | (tmpG<<8) | tmpB;
	}

	int newX = x + tmp_xVel;
	int newY = y + tmp_yVel;
	
	//if y and x have not changed, reassign recalced stuff
	if(newX ==x && newY==y){topMap[newX][newY]->color = tmp_color;}
	
	//if new location is different, reassign pixel_desc structs
	if(newX!=x || newY!=y )
	   {
		/* THESE REVERSE VELOCITY IF THE EDGE OF SCREEN IS REACHED*/
		if(newX<=0){newX=1;tmp_xVel=tmp_xVel*(-1);}

		if(newX>=WIDTH){newX=WIDTH-1;tmp_xVel=tmp_xVel*(-1);}

		if(newY<=0){newY=1;tmp_yVel=tmp_yVel*(-1);}

		if(newY>=HEIGHT){newY=HEIGHT-1;tmp_yVel=tmp_yVel*(-1);}	
		
		//posistion is finalized, set color
		topMap[newX][newY]->color = tmp_color;
		
		//double check position, probably not needed
	   if((newX>0 && newX<WIDTH) && (newY>0 && newY<HEIGHT))
	      {

	//find in mass List to switch pointer
	for(int i=0; i<massList.size();i++)
		{
		if(massList[i]->x == x && massList[i]->y == y)
			massList[i] = topMap[newX][newY];
		}

		topMap[newX][newY]->x = newX;
		topMap[newX][newY]->y = newY;


		topMap[newX][newY]->accelLength = topMap[x][y]->accelLength;

		topMap[newX][newY]->mass = topMap[x][y]->mass;


		

		topMap[x][y]->mass=0;

		topMap[newX][newY]->xAcc = topMap[x][y]->xAcc;
		topMap[newX][newY]->yAcc = topMap[x][y]->yAcc;

		topMap[newX][newY]->xGacc = topMap[x][y]->xGacc;
		topMap[newX][newY]->yGacc = topMap[x][y]->yGacc;

		topMap[newX][newY]->xVel = tmp_xVel;
		topMap[newX][newY]->yVel = tmp_yVel;

		topMap[newX][newY]->ID = topMap[x][y]->ID;

		topMap[newX][newY]->updated=1;
		topMap[newX][newY]->dimFactor=tmp_dimFactor;
		
		topMap[x][y]->color=0;

		topMap[x][y]->xAcc=0;
		topMap[x][y]->yAcc=0;

		topMap[x][y]->accelLength=0;

		topMap[x][y]->ID=0;

		topMap[x][y]->xVel=0;
		topMap[x][y]->yVel=0;
		topMap[x][y]->updated=0;
		topMap[x][y]->dimFactor=0;
	      }
//	printf("ID[%d]:old->:(%d,%d) vel:(%d,%d)\nnew->:(%d,%d) vel:(%d,%d)\n\n",
//topMap[newX][newY]->ID,	x,y,topMap[x][y]->xVel,topMap[x][y]->yVel, newX,newY,tmp_xVel,tmp_yVel);
	   
	}
   }
  }
 }
	setUpdateOnMap(0);

}

void Game :: setUpdateOnMap(int set)
{
 #pragma omp parallel for	
 for(int i=0 ; i< WIDTH ; i++)
	for(int j =0 ; j<HEIGHT ; j++)
		{
			topMap[i][j]->updated=set;
		}

}


void Game :: run()
{
char choice = 'e';
int FPS=0;
Uint32  T1, T2;		
	testStuff(choice);
//	T1=SDL_GetTicks();

	//	updateMap();
	//	parseMapToSurface();
	while(!done)
	{
		if(space)	
		testStuff(choice);

		handleEvents();
	thisTime=(float)SDL_GetTicks();
		updateMap();			
	//	calcGravFromSelect();
	//	applyGravToSelect();
		
	
		parseMapToSurface();
		gameRender->OnRender();
//	T2=SDL_GetTicks();
	FPS++;	
	}
printf("\t\nFPS:%f\n", (FPS/(float)(SDL_GetTicks()-T1))*1000.0);

}

void Game :: handleEvents()
{
	while(SDL_PollEvent(&event))
	{
		if(event.type == SDL_QUIT)
			done = true;

		if(event.type == SDL_KEYDOWN)
			{
			if(event.key.keysym.sym == SDLK_ESCAPE)
				done = true;

			if(event.key.keysym.sym == SDLK_SPACE)
				space = true;
			}

		if(event.type == SDL_KEYUP)
			{

			if(event.key.keysym.sym == SDLK_SPACE)
				space = false;
			}


			
	}

}

void Game :: testStuff(char choice)
{
int ticks;
//char choice = 'g';

switch (choice)
 {

	case 'r':
	{
	#pragma omp parallel for	
		for(int i = 0; i<200; i++)
  			 {
			ticks = SDL_GetTicks();
			srand(ticks);
	
		gameRender->putPixel(rand()%1021,rand()%765,0x0000FF,0);
			}		
	  break;
	}


	case 'e':
	{

	srand(SDL_GetTicks());
		float theta=0.0;
		float radius = 10.0;
		int xCent = 400, yCent = 400;
		int xPos=xCent, yPos=yCent;
		for(theta = 0.0 ; theta <6.30 ;theta+=.001)
		{
		xPos =xCent +  cos(theta)*radius;
		yPos =yCent +  sin(theta)*radius; 
		
			    assignMapElement(xPos, // x position
					     yPos, //y position
					     0xff22f3,	//color
			     (xPos-xCent)/3+rand()%10-rand()%10,//x Acceleration
			     (yPos-yCent)/3+rand()%10-rand()%10,//y Aceleration
					    1,//how long to accel	
					   //  0);
						1+rand()%20,//dim factor
						2);//mass
		}


	  break;
	}

	case 'g':
	{
		    assignMapElement(200, // x position
				     200, //y position
				     0xff22f3,	//color
		     			1,//x Acceleration
				     	1,//y Aceleration
				    1,//how long to accel	
				   //  0);
					0,//dim factor
					10);//mass
		    assignMapElement(200, // x position
				     240, //y position
				     0xff22f3,	//color
		     			0,//x Acceleration
				     	0,//y Aceleration
				    1,//how long to accel	
				   //  0);
					0,//dim factor
					50);//mass
	  break;
	}
	


	case 'm':
	{
	srand(SDL_GetTicks());
		float theta=0.0;
		float radius = 10.0;
		int xCent = 400, yCent = 400;
		int xPos=xCent, yPos=yCent;
	Uint8 red=0xFF, green=0, blue=0;	

if (SDL_MUSTLOCK(gameRender->mainScreen)) 
    SDL_LockSurface(gameRender->mainScreen);	

		for(xCent=400 ;xCent <500 ;xCent++)
		{
			for(yCent=400;yCent<500;yCent++)
			{	gameRender->putPixel(xCent,yCent, 0xff0000, 0);
	//	gameRender->putPixel2(xCent,yCent, red, green, blue);
			}
		}

    if( SDL_MUSTLOCK(gameRender->mainScreen) )
        SDL_UnlockSurface(gameRender->mainScreen);

	  break;
	}


 }
}

int Game :: getDistance(int x1, int y1, int x2, int y2)
{
//printf("sqrt((%d - %d)^2 + (%d - %d)^2)",x2,x1,y2,y1);

return ( sqrt( ((x2-x1)*(x2-x1)) + ((y2-y1)*(y2-y1))  ) );
}

void Game :: setGravAcc(int x, int y, int gXaccel, int gYaccel)
{
	gravMap[x][y]->gXacc = gXaccel;
	gravMap[x][y]->gYacc = gYaccel;
}

void Game :: addGravAcc(int x, int y, int gXaccel, int gYaccel)
{
	gravMap[x][y]->gXacc += gXaccel;
	gravMap[x][y]->gYacc += gYaccel;
}


//Set all grav points to some values
void Game :: setAllGrav(int setXacc, int setYacc)
{
#pragma omp parallel for
for(int x = 0 ; x<WIDTH ; x++)
 {
  for(int y = 0; y<HEIGHT ;y++)
  {	
	gravMap[x][y]->gXacc = setXacc;
	gravMap[x][y]->gYacc = setYacc;	
  }
 }

}


//instead of applying gravity to all parts, only apply to other objects
void Game ::  calcGravFromSelectObject()
{

int objX, objY, objMass, x, y, distance, deltaX, deltaY, gXacc, gYacc, gAccTotal;
float theta;

//top for picks the mass that will attract
for( int i = 0; i<massList.size(); i++)
	{

objX = massList[i]->x;
objY = massList[i]->y;
objMass =massList[i]->mass;

	//second loop iterates through other masses to apply accelertaion on
	for( int j = 0; j<massList.size(); j++)
		{
		if(i!=j){ 
			x = massList[j]->x;
			y = massList[j]->y;
			if(x!=objX || y!=objY)
			{	
//	printf("\t\nposition:(%d,%d) (%d,%d)\n", objX, objY, x,y);

			distance = getDistance(objX, objY, x, y);
			deltaX = objX - x;
			deltaY =objY - y;
	
			if(deltaY!=0)	
			 theta = atan((deltaX)/(deltaY));

			if((deltaX<0 && deltaY<0) || (deltaX>0 && deltaY<0))
			 {theta *=(-1);}

			if(distance!=0)
		 	 gAccTotal = (objMass*gravitationalConstant)/(distance);

 //printf("gAccTotal = (%d * %d)/(%d^2)=%d", objMass, gravitationalConstant, distance, gAccTotal); 

			gXacc = gAccTotal * sin(theta);
			gYacc = gAccTotal * cos(theta);	
		if(gXacc >2){gXacc=2;}
		if(gXacc <-2){gXacc=-2;}
	
		if(gYacc > 2){gYacc=2;}
		if(gYacc < -2){gYacc=-2;}
//printf("gravity:(%d,%d)\n",gXacc, gYacc);

		
			setGravAcc( x, y, gXacc, gYacc );
			}
			}
		}	 


	}
}

void Game :: calcGravFromSelect()
{
//first, erase grav map
setAllGrav(0,0);

//for( int i = 0; i<massList.size(); i++)
	calcGravFromSelectObject();

}
	


void Game :: applyGravToSelect()
{
//#pragma omp parallel for
for( int i = 0; i<massList.size(); i++)
	{
		
		massList[i]->xGacc = gravMap[massList[i]->x][massList[i]->y]->gXacc;
		massList[i]->yGacc = gravMap[massList[i]->x][massList[i]->y]->gYacc;
	 
	}
}
